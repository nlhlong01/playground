!function(t){var e={};function r(s){if(e[s])return e[s].exports;var o=e[s]={i:s,l:!1,exports:{}};return t[s].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=t,r.c=e,r.d=function(t,e,s){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)r.d(s,o,function(e){return t[e]}.bind(null,o));return s},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=2)}([,function(t,e,r){!function(){function e(t){for(var e=0,o=t.length-1,n=void 0,i=void 0,h=void 0,u=s(e,o);;){if(o<=e)return t[u];if(o==e+1)return t[e]>t[o]&&r(t,e,o),t[u];for(t[n=s(e,o)]>t[o]&&r(t,n,o),t[e]>t[o]&&r(t,e,o),t[n]>t[e]&&r(t,n,e),r(t,n,e+1),i=e+1,h=o;;){do{i++}while(t[e]>t[i]);do{h--}while(t[h]>t[e]);if(h<i)break;r(t,i,h)}r(t,e,h),h<=u&&(e=i),h>=u&&(o=h-1)}}var r=function(t,e,r){var s;return s=[t[r],t[e]],t[e]=s[0],t[r]=s[1],s},s=function(t,e){return~~((t+e)/2)};t.exports?t.exports=e:window.median=e}()},function(t,e,r){"use strict";r.r(e);const s=Object.prototype.toString;function o(t){return s.call(t).endsWith("Array]")}var n=function(t){if(!o(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=0,r=0;r<t.length;r++)e+=t[r];return e};var i=function(t){return n(t)/t.length},h=r(1),u=r.n(h);var l=function(t){if(!o(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");return u()(t.slice())};var a=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!o(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,s=void 0===r?0:r,n=e.toIndex,i=void 0===n?t.length:n;if(s<0||s>=t.length||!Number.isInteger(s))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=s||i>t.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var h=t[s],u=s+1;u<i;u++)t[u]>h&&(h=t[u]);return h};var c=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!o(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,s=void 0===r?0:r,n=e.toIndex,i=void 0===n?t.length:n;if(s<0||s>=t.length||!Number.isInteger(s))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=s||i>t.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var h=t[s],u=s+1;u<i;u++)t[u]<h&&(h=t[u]);return h};var f=function(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!o(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==r.output){if(!o(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);var s=c(t),n=a(t);if(s===n)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var i=r.min,h=void 0===i?r.autoMinMax?s:0:i,u=r.max,l=void 0===u?r.autoMinMax?n:1:u;if(h>=l)throw new RangeError("min option must be smaller than max option");for(var f=(l-h)/(n-s),m=0;m<t.length;m++)e[m]=(t[m]-s)*f+h;return e};const m=" ".repeat(2),w=" ".repeat(4);function p(t,e={}){const{maxRows:r=15,maxColumns:s=10,maxNumSize:o=8}=e;return`${t.constructor.name} {\n${m}[\n${w}${function(t,e,r,s){const{rows:o,columns:n}=t,i=Math.min(o,e),h=Math.min(n,r),u=[];for(let e=0;e<i;e++){let r=[];for(let o=0;o<h;o++)r.push(g(t.get(e,o),s));u.push(""+r.join(" "))}h!==n&&(u[u.length-1]+=` ... ${n-r} more columns`);i!==o&&u.push(`... ${o-e} more rows`);return u.join("\n"+w)}(t,r,s,o)}\n${m}]\n${m}rows: ${t.rows}\n${m}columns: ${t.columns}\n}`}function g(t,e){const r=String(t);if(r.length<=e)return r.padEnd(e," ");const s=t.toPrecision(e-2);if(s.length<=e)return s;const o=t.toExponential(e-2),n=o.indexOf("e"),i=o.slice(n);return o.slice(0,e-i.length)+i}function d(t,e,r){let s=r?t.rows:t.rows-1;if(e<0||e>s)throw new RangeError("Row index out of range")}function y(t,e,r){let s=r?t.columns:t.columns-1;if(e<0||e>s)throw new RangeError("Column index out of range")}function b(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function x(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function M(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for row indices");if(e.some(e=>e<0||e>=t.rows))throw new RangeError("row indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function S(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for column indices");if(e.some(e=>e<0||e>=t.columns))throw new RangeError("column indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function v(t,e,r,s,o){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(R("startRow",e),R("endRow",r),R("startColumn",s),R("endColumn",o),e>r||s>o||e<0||e>=t.rows||r<0||r>=t.rows||s<0||s>=t.columns||o<0||o>=t.columns)throw new RangeError("Submatrix indices are out of range")}function E(t,e=0){let r=[];for(let s=0;s<t;s++)r.push(e);return r}function R(t,e){if("number"!=typeof e)throw new TypeError(t+" must be a number")}class C{static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");let s=new F(t,e);for(let o=0;o<t;o++)for(let t=0;t<e;t++)s.set(o,t,r[o*e+t]);return s}static rowVector(t){let e=new F(1,t.length);for(let r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){let e=new F(t.length,1);for(let r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new F(t,e)}static ones(t,e){return new F(t,e).fill(1)}static rand(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{random:s=Math.random}=r;let o=new F(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)o.set(r,t,s());return o}static randInt(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{min:s=0,max:o=1e3,random:n=Math.random}=r;if(!Number.isInteger(s))throw new TypeError("min must be an integer");if(!Number.isInteger(o))throw new TypeError("max must be an integer");if(s>=o)throw new RangeError("min must be smaller than max");let i=o-s,h=new F(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let e=s+Math.round(n()*i);h.set(r,t,e)}return h}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);let s=Math.min(t,e),o=this.zeros(t,e);for(let t=0;t<s;t++)o.set(t,t,r);return o}static diag(t,e,r){let s=t.length;void 0===e&&(e=s),void 0===r&&(r=e);let o=Math.min(s,e,r),n=this.zeros(e,r);for(let e=0;e<o;e++)n.set(e,e,t[e]);return n}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,s=t.columns,o=new F(r,s);for(let n=0;n<r;n++)for(let r=0;r<s;r++)o.set(n,r,Math.min(t.get(n,r),e.get(n,r)));return o}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,s=t.columns,o=new this(r,s);for(let n=0;n<r;n++)for(let r=0;r<s;r++)o.set(n,r,Math.max(t.get(n,r),e.get(n,r)));return o}static checkMatrix(t){return C.isMatrix(t)?t:new F(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,r=-1,s=!0,o=!1;for(;t<this.rows&&s;){for(e=0,o=!1;e<this.columns&&!1===o;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(o=!0,r=e):(s=!1,o=!0);t++}return s}isReducedEchelonForm(){let t=0,e=0,r=-1,s=!0,o=!1;for(;t<this.rows&&s;){for(e=0,o=!1;e<this.columns&&!1===o;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(o=!0,r=e):(s=!1,o=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(s=!1);t++}return s}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let s=e;for(let o=e;o<t.rows;o++)t.get(o,r)>t.get(s,r)&&(s=o);if(0===t.get(s,r))r++;else{t.swapRows(e,s);let o=t.get(e,r);for(let s=r;s<t.columns;s++)t.set(e,s,t.get(e,s)/o);for(let s=e+1;s<t.rows;s++){let o=t.get(s,r)/t.get(e,r);t.set(s,r,0);for(let n=r+1;n<t.columns;n++)t.set(s,n,t.get(s,n)-t.get(e,n)*o)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,s=r-1;for(;s>=0;)if(0===t.maxRow(s))s--;else{let o=0,n=!1;for(;o<r&&!1===n;)1===t.get(s,o)?n=!0:o++;for(let r=0;r<s;r++){let n=t.get(r,o);for(let i=o;i<e;i++){let e=t.get(r,i)-n*t.get(s,i);t.set(r,i,e)}}s--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let s=new F(this.rows*e,this.columns*r);for(let t=0;t<e;t++)for(let e=0;e<r;e++)s.setSubMatrix(this,this.rows*t,this.columns*e);return s}fill(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){d(this,t);let e=[];for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return F.rowVector(this.getRow(t))}setRow(t,e){d(this,t),e=b(this,e);for(let r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){d(this,t),d(this,e);for(let r=0;r<this.columns;r++){let s=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,s)}return this}getColumn(t){y(this,t);let e=[];for(let r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return F.columnVector(this.getColumn(t))}setColumn(t,e){y(this,t),e=x(this,e);for(let r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){y(this,t),y(this,e);for(let r=0;r<this.rows;r++){let s=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,s)}return this}addRowVector(t){t=b(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=b(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=b(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=b(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=x(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=x(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=x(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=x(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){d(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){y(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(){let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxIndex(){let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t&&(t=this.get(r,s),e[0]=r,e[1]=s);return e}min(){let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minIndex(){let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t&&(t=this.get(r,s),e[0]=r,e[1]=s);return e}maxRow(t){d(this,t);let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){d(this,t);let e=this.get(t,0),r=[t,0];for(let s=1;s<this.columns;s++)this.get(t,s)>e&&(e=this.get(t,s),r[1]=s);return r}minRow(t){d(this,t);let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){d(this,t);let e=this.get(t,0),r=[t,0];for(let s=1;s<this.columns;s++)this.get(t,s)<e&&(e=this.get(t,s),r[1]=s);return r}maxColumn(t){y(this,t);let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){y(this,t);let e=this.get(0,t),r=[0,t];for(let s=1;s<this.rows;s++)this.get(s,t)>e&&(e=this.get(s,t),r[0]=s);return r}minColumn(t){y(this,t);let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){y(this,t);let e=this.get(0,t),r=[0,t];for(let s=1;s<this.rows;s++)this.get(s,t)<e&&(e=this.get(s,t),r[0]=s);return r}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let r=0;r<t;r++)e.push(this.get(r,r));return e}norm(t="frobenius"){let e=0;if("max"===t)return this.max();if("frobenius"===t){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r)*this.get(t,r);return Math.sqrt(e)}throw new RangeError("unknown norm type: "+t)}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){C.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let s=0;s<e.length;s++)r+=e[s]*t[s];return r}mmul(t){t=F.checkMatrix(t);let e=this.rows,r=this.columns,s=t.columns,o=new F(e,s),n=new Float64Array(r);for(let i=0;i<s;i++){for(let e=0;e<r;e++)n[e]=t.get(e,i);for(let t=0;t<e;t++){let e=0;for(let s=0;s<r;s++)e+=this.get(t,s)*n[s];o.set(t,i,e)}}return o}strassen2x2(t){t=F.checkMatrix(t);let e=new F(2,2);const r=this.get(0,0),s=t.get(0,0),o=this.get(0,1),n=t.get(0,1),i=this.get(1,0),h=t.get(1,0),u=this.get(1,1),l=t.get(1,1),a=(r+u)*(s+l),c=(i+u)*s,f=r*(n-l),m=u*(h-s),w=(r+o)*l,p=a+m-w+(o-u)*(h+l),g=f+w,d=c+m,y=a-c+f+(i-r)*(s+n);return e.set(0,0,p),e.set(0,1,g),e.set(1,0,d),e.set(1,1,y),e}strassen3x3(t){t=F.checkMatrix(t);let e=new F(3,3);const r=this.get(0,0),s=this.get(0,1),o=this.get(0,2),n=this.get(1,0),i=this.get(1,1),h=this.get(1,2),u=this.get(2,0),l=this.get(2,1),a=this.get(2,2),c=t.get(0,0),f=t.get(0,1),m=t.get(0,2),w=t.get(1,0),p=t.get(1,1),g=t.get(1,2),d=t.get(2,0),y=t.get(2,1),b=t.get(2,2),x=(r-n)*(-f+p),M=(-r+n+i)*(c-f+p),S=(n+i)*(-c+f),v=r*c,E=(-r+u+l)*(c-m+g),R=(-r+u)*(m-g),C=(u+l)*(-c+m),A=(-o+l+a)*(p+d-y),T=(o-a)*(p-y),k=o*d,I=(l+a)*(-d+y),N=(-o+i+h)*(g+d-b),j=(o-h)*(g-b),O=(i+h)*(-d+b),q=v+k+s*w,V=(r+s+o-n-i-l-a)*p+M+S+v+A+k+I,P=v+E+C+(r+s+o-i-h-u-l)*g+k+N+O,D=x+i*(-c+f+w-p-g-d+b)+M+v+k+N+j,z=x+M+S+v+h*y,$=k+N+j+O+n*m,X=v+E+R+l*(-c+m+w-p-g-d+y)+A+T+k,J=A+T+k+I+u*f,B=v+E+R+C+a*b;return e.set(0,0,q),e.set(0,1,V),e.set(0,2,P),e.set(1,0,D),e.set(1,1,z),e.set(1,2,$),e.set(2,0,X),e.set(2,1,J),e.set(2,2,B),e}mmulStrassen(t){t=F.checkMatrix(t);let e=this.clone(),r=e.rows,s=e.columns,o=t.rows,n=t.columns;function i(t,e,r){let s=t.rows,o=t.columns;if(s===e&&o===r)return t;{let s=C.zeros(e,r);return s=s.setSubMatrix(t,0,0),s}}s!==o&&console.warn(`Multiplying ${r} x ${s} and ${o} x ${n} matrix: dimensions do not match.`);let h=Math.max(r,o),u=Math.max(s,n);return e=i(e,h,u),function t(e,r,s,o){if(s<=512||o<=512)return e.mmul(r);s%2==1&&o%2==1?(e=i(e,s+1,o+1),r=i(r,s+1,o+1)):s%2==1?(e=i(e,s+1,o),r=i(r,s+1,o)):o%2==1&&(e=i(e,s,o+1),r=i(r,s,o+1));let n=parseInt(e.rows/2,10),h=parseInt(e.columns/2,10),u=e.subMatrix(0,n-1,0,h-1),l=r.subMatrix(0,n-1,0,h-1),a=e.subMatrix(0,n-1,h,e.columns-1),c=r.subMatrix(0,n-1,h,r.columns-1),f=e.subMatrix(n,e.rows-1,0,h-1),m=r.subMatrix(n,r.rows-1,0,h-1),w=e.subMatrix(n,e.rows-1,h,e.columns-1),p=r.subMatrix(n,r.rows-1,h,r.columns-1),g=t(C.add(u,w),C.add(l,p),n,h),d=t(C.add(f,w),l,n,h),y=t(u,C.sub(c,p),n,h),b=t(w,C.sub(m,l),n,h),x=t(C.add(u,a),p,n,h),M=t(C.sub(f,u),C.add(l,c),n,h),S=t(C.sub(a,w),C.add(m,p),n,h),v=C.add(g,b);v.sub(x),v.add(S);let E=C.add(y,x),R=C.add(d,b),A=C.sub(g,d);A.add(y),A.add(M);let F=C.zeros(2*v.rows,2*v.columns);return F=F.setSubMatrix(v,0,0),F=F.setSubMatrix(E,v.rows,0),F=F.setSubMatrix(R,0,v.columns),F=F.setSubMatrix(A,v.rows,v.columns),F.subMatrix(0,s-1,0,o-1)}(e,t=i(t,h,u),h,u)}scaleRows(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let s=new F(this.rows,this.columns);for(let t=0;t<this.rows;t++){const o=this.getRow(t);f(o,{min:e,max:r,output:o}),s.setRow(t,o)}return s}scaleColumns(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let s=new F(this.rows,this.columns);for(let t=0;t<this.columns;t++){const o=this.getColumn(t);f(o,{min:e,max:r,output:o}),s.setColumn(t,o)}return s}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let r=0;r<t;r++){let t=this.get(e,r),s=this.get(e,this.columns-1-r);this.set(e,r,s),this.set(e,this.columns-1-r,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let r=0;r<t;r++){let t=this.get(r,e),s=this.get(this.rows-1-r,e);this.set(r,e,s),this.set(this.rows-1-r,e,t)}return this}kroneckerProduct(t){t=F.checkMatrix(t);let e=this.rows,r=this.columns,s=t.rows,o=t.columns,n=new F(e*s,r*o);for(let i=0;i<e;i++)for(let e=0;e<r;e++)for(let r=0;r<s;r++)for(let h=0;h<o;h++)n.set(s*i+r,o*e+h,this.get(i,e)*t.get(r,h));return n}transpose(){let t=new F(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(t=A){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(t=A){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,s){v(this,t,e,r,s);let o=new F(e-t+1,s-r+1);for(let n=t;n<=e;n++)for(let e=r;e<=s;e++)o.set(n-t,e-r,this.get(n,e));return o}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let s=new F(t.length,r-e+1);for(let o=0;o<t.length;o++)for(let n=e;n<=r;n++){if(t[o]<0||t[o]>=this.rows)throw new RangeError("Row index out of range: "+t[o]);s.set(o,n-e,this.get(t[o],n))}return s}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let s=new F(r-e+1,t.length);for(let o=0;o<t.length;o++)for(let n=e;n<=r;n++){if(t[o]<0||t[o]>=this.columns)throw new RangeError("Column index out of range: "+t[o]);s.set(n-e,o,this.get(n,t[o]))}return s}setSubMatrix(t,e,r){v(this,e,e+(t=F.checkMatrix(t)).rows-1,r,r+t.columns-1);for(let s=0;s<t.rows;s++)for(let o=0;o<t.columns;o++)this.set(e+s,r+o,t.get(s,o));return this}selection(t,e){let r=function(t,e,r){return{row:M(t,e),column:S(t,r)}}(this,t,e),s=new F(t.length,e.length);for(let t=0;t<r.row.length;t++){let e=r.row[t];for(let o=0;o<r.column.length;o++){let n=r.column[o];s.set(t,o,this.get(e,n))}}return s}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let r=0;r<t;r++)e+=this.get(r,r);return e}clone(){let t=new F(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(e,r,this.get(e,r));return t}sum(t){switch(t){case"row":return function(t){let e=E(t.rows);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[r]+=t.get(r,s);return e}(this);case"column":return function(t){let e=E(t.columns);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[s]+=t.get(r,s);return e}(this);case void 0:return function(t){let e=0;for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)e+=t.get(r,s);return e}(this);default:throw new Error("invalid option: "+t)}}product(t){switch(t){case"row":return function(t){let e=E(t.rows,1);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[r]*=t.get(r,s);return e}(this);case"column":return function(t){let e=E(t.columns,1);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[s]*=t.get(r,s);return e}(this);case void 0:return function(t){let e=1;for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)e*=t.get(r,s);return e}(this);default:throw new Error("invalid option: "+t)}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error("invalid option: "+t)}}variance(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:s=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!Array.isArray(s))throw new TypeError("mean must be an array");return function(t,e,r){const s=t.rows,o=t.columns,n=[];for(let i=0;i<s;i++){let s=0,h=0,u=0;for(let e=0;e<o;e++)u=t.get(i,e)-r[i],s+=u,h+=u*u;e?n.push((h-s*s/o)/(o-1)):n.push((h-s*s/o)/o)}return n}(this,r,s);case"column":if(!Array.isArray(s))throw new TypeError("mean must be an array");return function(t,e,r){const s=t.rows,o=t.columns,n=[];for(let i=0;i<o;i++){let o=0,h=0,u=0;for(let e=0;e<s;e++)u=t.get(e,i)-r[i],o+=u,h+=u*u;e?n.push((h-o*o/s)/(s-1)):n.push((h-o*o/s)/s)}return n}(this,r,s);case void 0:if("number"!=typeof s)throw new TypeError("mean must be a number");return function(t,e,r){const s=t.rows,o=t.columns,n=s*o;let i=0,h=0,u=0;for(let e=0;e<s;e++)for(let s=0;s<o;s++)u=t.get(e,s)-r,i+=u,h+=u*u;return e?(h-i*i/n)/(n-1):(h-i*i/n)/n}(this,r,s);default:throw new Error("invalid option: "+t)}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(let t=0;t<r.length;t++)r[t]=Math.sqrt(r[t]);return r}center(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!Array.isArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e[r])}(this,r),this;case"column":if(!Array.isArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e[s])}(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e)}(this,r),this;default:throw new Error("invalid option: "+t)}}scale(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.rows;r++){let s=0;for(let e=0;e<t.columns;e++)s+=Math.pow(t.get(r,e),2)/(t.columns-1);e.push(Math.sqrt(s))}return e}(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e[r])}(this,r),this;case"column":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.columns;r++){let s=0;for(let e=0;e<t.rows;e++)s+=Math.pow(t.get(e,r),2)/(t.rows-1);e.push(Math.sqrt(s))}return e}(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e[s])}(this,r),this;case void 0:if(void 0===r)r=function(t){const e=t.size-1;let r=0;for(let s=0;s<t.columns;s++)for(let o=0;o<t.rows;o++)r+=Math.pow(t.get(o,s),2)/e;return Math.sqrt(r)}(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e)}(this,r),this;default:throw new Error("invalid option: "+t)}}toString(t){return p(this,t)}}function A(t,e){return t-e}C.prototype.klass="Matrix","undefined"!=typeof Symbol&&(C.prototype[Symbol.for("nodejs.util.inspect.custom")]=function(){return p(this)}),C.random=C.rand,C.randomInt=C.randInt,C.diagonal=C.diag,C.prototype.diagonal=C.prototype.diag,C.identity=C.eye,C.prototype.negate=C.prototype.neg,C.prototype.tensorProduct=C.prototype.kroneckerProduct;class F extends C{constructor(t,e){if(super(),F.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>0){if(this.data=[],!(Number.isInteger(e)&&e>0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e))}else{if(!Array.isArray(t))throw new TypeError("First argument must be a positive number or an array");{const r=t;if(t=r.length,"number"!=typeof(e=r[0].length)||0===e)throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let s=0;s<t;s++){if(r[s].length!==e)throw new RangeError("Inconsistent array dimensions");this.data.push(Float64Array.from(r[s]))}}}this.rows=t,this.columns=e}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){if(d(this,t),1===this.rows)throw new RangeError("A matrix cannot have less than one row");return this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),d(this,t,!0),e=Float64Array.from(b(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){if(y(this,t),1===this.columns)throw new RangeError("A matrix cannot have less than one column");for(let e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let s=0;s<t;s++)r[s]=this.data[e][s];for(let s=t+1;s<this.columns;s++)r[s-1]=this.data[e][s];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),y(this,t,!0),e=x(this,e);for(let r=0;r<this.rows;r++){const s=new Float64Array(this.columns+1);let o=0;for(;o<t;o++)s[o]=this.data[r][o];for(s[o++]=e[r];o<this.columns+1;o++)s[o]=this.data[r][o-1];this.data[r]=s}return this.columns+=1,this}}var T,k;function I(t,e){let r=new Array(e).fill(0);for(let e=0;e<t.length;++e)r[t[e]]+=1/t.length;return F.rowVector(r)}function N(t){if(0===t.length)return 0;let e=I(t,j(t)).getRow(0),r=0;for(let t=0;t<e.length;++t)r+=e[t]*e[t];return 1-r}function j(t){return t.filter((function(t,e,r){return r.indexOf(t)===e})).map(t=>t+1).reduce((t,e)=>Math.max(t,e))}function O(t){let e=t.length;if(0===e)return 0;let r=i(t),s=0;for(let o=0;o<e;++o){let e=t[o];s+=(e-r)*(e-r)}return s}k=F,(T=C).prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},T.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},T.prototype.addM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t.get(e,r));return this},T.add=function(t,e){return new k(t).add(e)},T.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},T.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},T.prototype.subM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t.get(e,r));return this},T.sub=function(t,e){return new k(t).sub(e)},T.prototype.subtract=T.prototype.sub,T.prototype.subtractS=T.prototype.subS,T.prototype.subtractM=T.prototype.subM,T.subtract=T.sub,T.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},T.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},T.prototype.mulM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t.get(e,r));return this},T.mul=function(t,e){return new k(t).mul(e)},T.prototype.multiply=T.prototype.mul,T.prototype.multiplyS=T.prototype.mulS,T.prototype.multiplyM=T.prototype.mulM,T.multiply=T.mul,T.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},T.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},T.prototype.divM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t.get(e,r));return this},T.div=function(t,e){return new k(t).div(e)},T.prototype.divide=T.prototype.div,T.prototype.divideS=T.prototype.divS,T.prototype.divideM=T.prototype.divM,T.divide=T.div,T.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},T.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},T.prototype.modM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t.get(e,r));return this},T.mod=function(t,e){return new k(t).mod(e)},T.prototype.modulus=T.prototype.mod,T.prototype.modulusS=T.prototype.modS,T.prototype.modulusM=T.prototype.modM,T.modulus=T.mod,T.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},T.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},T.prototype.andM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t.get(e,r));return this},T.and=function(t,e){return new k(t).and(e)},T.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},T.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},T.prototype.orM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t.get(e,r));return this},T.or=function(t,e){return new k(t).or(e)},T.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},T.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},T.prototype.xorM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t.get(e,r));return this},T.xor=function(t,e){return new k(t).xor(e)},T.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},T.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},T.prototype.leftShiftM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t.get(e,r));return this},T.leftShift=function(t,e){return new k(t).leftShift(e)},T.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},T.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},T.prototype.signPropagatingRightShiftM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t.get(e,r));return this},T.signPropagatingRightShift=function(t,e){return new k(t).signPropagatingRightShift(e)},T.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},T.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},T.prototype.rightShiftM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t.get(e,r));return this},T.rightShift=function(t,e){return new k(t).rightShift(e)},T.prototype.zeroFillRightShift=T.prototype.rightShift,T.prototype.zeroFillRightShiftS=T.prototype.rightShiftS,T.prototype.zeroFillRightShiftM=T.prototype.rightShiftM,T.zeroFillRightShift=T.rightShift,T.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},T.not=function(t){return new k(t).not()},T.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},T.abs=function(t){return new k(t).abs()},T.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},T.acos=function(t){return new k(t).acos()},T.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},T.acosh=function(t){return new k(t).acosh()},T.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},T.asin=function(t){return new k(t).asin()},T.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},T.asinh=function(t){return new k(t).asinh()},T.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},T.atan=function(t){return new k(t).atan()},T.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},T.atanh=function(t){return new k(t).atanh()},T.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},T.cbrt=function(t){return new k(t).cbrt()},T.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},T.ceil=function(t){return new k(t).ceil()},T.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},T.clz32=function(t){return new k(t).clz32()},T.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},T.cos=function(t){return new k(t).cos()},T.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},T.cosh=function(t){return new k(t).cosh()},T.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},T.exp=function(t){return new k(t).exp()},T.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},T.expm1=function(t){return new k(t).expm1()},T.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},T.floor=function(t){return new k(t).floor()},T.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},T.fround=function(t){return new k(t).fround()},T.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},T.log=function(t){return new k(t).log()},T.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},T.log1p=function(t){return new k(t).log1p()},T.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},T.log10=function(t){return new k(t).log10()},T.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},T.log2=function(t){return new k(t).log2()},T.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},T.round=function(t){return new k(t).round()},T.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},T.sign=function(t){return new k(t).sign()},T.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},T.sin=function(t){return new k(t).sin()},T.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},T.sinh=function(t){return new k(t).sinh()},T.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},T.sqrt=function(t){return new k(t).sqrt()},T.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},T.tan=function(t){return new k(t).tan()},T.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},T.tanh=function(t){return new k(t).tanh()},T.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},T.trunc=function(t){return new k(t).trunc()},T.pow=function(t,e){return new k(t).pow(e)},T.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},T.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t));return this},T.prototype.powM=function(t){if(t=k.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t.get(e,r)));return this};const q={gini:function(t,e){let r=0,s=["greater","lesser"];for(let o=0;o<s.length;++o){let n=e[s[o]];r+=N(n)*n.length/t.length}return N(t)-r},regression:function(t,e){let r=0,s=["greater","lesser"];for(let t=0;t<s.length;++t){r+=O(e[s[t]])}return r}},V={mean:function(t,e){return(t+e)/2}};class P{constructor(t){this.kind=t.kind,this.gainFunction=t.gainFunction,this.splitFunction=t.splitFunction,this.minNumSamples=t.minNumSamples,this.maxDepth=t.maxDepth}bestSplit(t,e){let r,s,o="classifier"===this.kind?-1/0:1/0,n="classifier"===this.kind?(t,e)=>t>e:(t,e)=>t<e;for(let i=0;i<t.rows;++i){let h=t.getRow(i),u=this.featureSplit(h,e);for(let t=0;t<u.length;++t){let l=u[t],a=this.split(h,e,l),c=q[this.gainFunction](e,a);n(c,o)&&(r=i,s=l,o=c)}}return{maxGain:o,maxColumn:r,maxValue:s}}split(t,e,r){let s=[],o=[];for(let n=0;n<t.length;++n)t[n]<r?s.push(e[n]):o.push(e[n]);return{greater:o,lesser:s}}featureSplit(t,e){let r=[],s=function(t,e){if(t.length!==e.length)throw new TypeError(`Error on zip: the size of a: ${t.length} is different from b: ${e.length}`);let r=new Array(t.length);for(let s=0;s<t.length;++s)r[s]=[t[s],e[s]];return r}(t,e);s.sort((function(t,e){return t[0]-e[0]}));for(let t=1;t<s.length;++t)s[t-1][1]!==s[t][1]&&r.push(V[this.splitFunction](s[t-1][0],s[t][0]));return r}calculatePrediction(t){if("classifier"===this.kind){if(this.distribution=I(t,j(t)),0===this.distribution.columns)throw new TypeError("Error on calculate the prediction")}else this.distribution=i(t)}train(t,e,r,s){if(t.rows<=this.minNumSamples)return void this.calculatePrediction(e);void 0===s&&(s=0);let o=t.transpose(),n=this.bestSplit(o,e);this.splitValue=n.maxValue,this.splitColumn=n.maxColumn,this.gain=n.maxGain;let i=function(t,e,r,s){let o=[],n=[],i=[],h=[];for(let u=0;u<t.rows;++u)t.get(u,r)<s?(o.push(t.getRow(u)),i.push(e[u])):(n.push(t.getRow(u)),h.push(e[u]));return{greaterX:n,greaterY:h,lesserX:o,lesserY:i}}(t,e,this.splitColumn,this.splitValue);if(r<this.maxDepth&&this.gain>.01&&this.gain!==s&&i.lesserX.length>0&&i.greaterX.length>0){this.left=new P(this),this.right=new P(this);let t=new F(i.lesserX),e=new F(i.greaterX);this.left.train(t,i.lesserY,r+1,this.gain),this.right.train(e,i.greaterY,r+1,this.gain)}else this.calculatePrediction(e)}classify(t){return this.right&&this.left?t[this.splitColumn]<this.splitValue?this.left.classify(t):this.right.classify(t):this.distribution}setNodeParameters(t){void 0!==t.distribution?this.distribution=t.distribution.constructor===Array?new F(t.distribution):t.distribution:(this.distribution=void 0,this.splitValue=t.splitValue,this.splitColumn=t.splitColumn,this.gain=t.gain,this.left=new P(this),this.right=new P(this),t.left!=={}&&this.left.setNodeParameters(t.left),t.right!=={}&&this.right.setNodeParameters(t.right))}}const D={gainFunction:"gini",splitFunction:"mean",minNumSamples:3,maxDepth:1/0};class z{constructor(t,e){!0===t?(this.options=e.options,this.root=new P(e.options),this.root.setNodeParameters(e.root)):(this.options=Object.assign({},D,t),this.options.kind="classifier")}train(t,e){this.root=new P(this.options),t=F.checkMatrix(t),this.root.train(t,e,0,null)}predict(t){t=F.checkMatrix(t);let e=new Array(t.rows);for(let r=0;r<t.rows;++r)e[r]=this.root.classify(t.getRow(r)).maxRowIndex(0)[1];return e}toJSON(){return{options:this.options,root:this.root,name:"DTClassifier"}}static load(t){if("DTClassifier"!==t.name)throw new RangeError("Invalid model: "+t.name);return new z(!0,t)}}const $={gainFunction:"regression",splitFunction:"mean",minNumSamples:3,maxDepth:1/0};class X{constructor(t,e){!0===t?(this.options=e.options,this.root=new P(e.options),this.root.setNodeParameters(e.root)):(this.options=Object.assign({},$,t),this.options.kind="regression")}train(t,e){this.root=new P(this.options),t=void 0!==t[0]&&void 0===t[0].length?F.columnVector(t):F.checkMatrix(t),this.root.train(t,e,0)}predict(t){void 0!==t[0]&&void 0===t[0].length&&(t=F.columnVector(t)),t=F.checkMatrix(t);let e=new Array(t.rows);for(let r=0;r<t.rows;++r)e[r]=this.root.classify(t.getRow(r));return e}toJSON(){return{options:this.options,root:this.root,name:"DTRegression"}}static load(t){if("DTRegression"!==t.name)throw new RangeError("Invalid model:"+t.name);return new X(!0,t)}}class J extends C{constructor(t,e,r){super(),this.matrix=t,this.rows=e,this.columns=r}}class B extends J{constructor(t,e){e=S(t,e),super(t,t.rows,e.length),this.columnIndices=e}set(t,e,r){return this.matrix.set(t,this.columnIndices[e],r),this}get(t,e){return this.matrix.get(t,this.columnIndices[e])}}class _ extends J{constructor(t){super(t,t.columns,t.rows)}set(t,e,r){return this.matrix.set(e,t,r),this}get(t,e){return this.matrix.get(e,t)}}class Y extends C{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}}function G(t){return t>0&&t<=1}function U(t,e){return Math.round(Math.random()*(e-t)+t)}function W(t,e,r){let s=new Array(r),o=new Array(r);for(let n=0;n<r;++n){let i=U(0,r-1);s[n]=t.getRow(i),o[n]=e[i]}return{X:new F(s),y:o}}function H(t,e,r){if(t.columns<e)throw new RangeError("N should be less or equal to the number of columns of X");let s,o,n=new F(t.rows,e);if(r){s=new Array(e);for(let r=0;r<e;++r)o=U(0,t.columns-1),s[r]=o,n.setColumn(r,t.getColumn(o))}else{s=new Set,o=U(0,t.columns-1);for(let r=0;r<e;++r){for(;s.has(o);)o=U(0,t.columns-1);n.setColumn(r,t.getColumn(o)),s.add(o)}s=Array.from(s)}return{X:n,usedIndex:s}}const K={mean:i,median:l,mode:function(t){return t.sort((e,r)=>t.filter(t=>t===e).length-t.filter(t=>t===r).length).pop()}},L={replacement:!0,maxSamples:.8,maxFeatures:1,nEstimators:10,selectionMethod:"mode",seed:42,useSampleBagging:!1};class Q extends class{constructor(t,e){if(!0===t){this.replacement=e.replacement,this.maxSamples=e.maxSamples,this.maxFeatures=e.maxFeatures,this.nEstimators=e.nEstimators,this.treeOptions=e.treeOptions,this.isClassifier=e.isClassifier,this.seed=e.seed,this.nSamples=e.nSamples,this.nFeatures=e.nFeatures,this.indexes=e.indexes,this.useSampleBagging=e.useSampleBagging;let t=this.isClassifier?z:X;this.estimators=e.estimators.map(e=>t.load(e))}else this.replacement=t.replacement,this.maxSamples=t.maxSamples,this.maxFeatures=t.maxFeatures,this.nEstimators=t.nEstimators,this.treeOptions=t.treeOptions,this.isClassifier=t.isClassifier,this.seed=t.seed,this.useSampleBagging=t.useSampleBagging}train(t,e){if(t=F.checkMatrix(t),this.maxFeatures=this.maxFeatures||t.columns,G(this.maxFeatures))this.nFeatures=Math.floor(t.columns*this.maxFeatures);else{if(!Number.isInteger(this.maxFeatures))throw new RangeError("Cannot process the maxFeatures parameter "+this.maxFeatures);if(this.maxFeatures>t.columns)throw new RangeError("The maxFeatures parameter should be less than "+t.columns);this.nFeatures=this.maxFeatures}if(G(this.maxSamples))this.nSamples=Math.floor(t.rows*this.maxSamples);else{if(!Number.isInteger(this.maxSamples))throw new RangeError("Cannot process the maxSamples parameter "+this.maxSamples);if(this.maxSamples>t.rows)throw new RangeError("The maxSamples parameter should be less than "+t.rows);this.nSamples=this.maxSamples}let r;r=this.isClassifier?z:X,this.estimators=new Array(this.nEstimators),this.indexes=new Array(this.nEstimators);for(let s=0;s<this.nEstimators;++s){let o=this.useSampleBagging?W(t,e,this.nSamples):{X:t,y:e},n=o.X,i=o.y;o=H(n,this.nFeatures,this.replacement,this.seed),n=o.X,this.indexes[s]=o.usedIndex,this.estimators[s]=new r(this.treeOptions),this.estimators[s].train(n,i)}}selection(t){throw new Error("Abstract method 'selection' not implemented!")}predict(t){let e=new Array(this.nEstimators);t=F.checkMatrix(t);for(let r=0;r<this.nEstimators;++r){let s=new B(t,this.indexes[r]);e[r]=this.estimators[r].predict(s)}e=new _(new Y(e));let r=new Array(e.rows);for(let t=0;t<e.rows;++t)r[t]=this.selection(e.getRow(t));return{predictions:r,predictionValues:e.to2DArray()}}toJSON(){return{indexes:this.indexes,nSamples:this.nSamples,nFeatures:this.nFeatures,replacement:this.replacement,maxSamples:this.maxSamples,maxFeatures:this.maxFeatures,nEstimators:this.nEstimators,treeOptions:this.treeOptions,isClassifier:this.isClassifier,seed:this.seed,estimators:this.estimators.map(t=>t.toJSON()),useSampleBagging:this.useSampleBagging}}}{constructor(t,e){if(!0===t)super(!0,e.baseModel),this.selectionMethod=e.selectionMethod;else{if("mean"!==(t=Object.assign({},L,t)).selectionMethod&&"median"!==t.selectionMethod&&"mode"!==t.selectionMethod)throw new RangeError("Unsupported selection method "+t.selectionMethod);t.isClassifier=!0,super(t),this.selectionMethod=t.selectionMethod}}selection(t){return K[this.selectionMethod](t)}toJSON(){return{baseModel:super.toJSON(),selectionMethod:this.selectionMethod,name:"RFClassifier"}}static load(t){if("RFClassifier"!==t.name)throw new RangeError("Invalid model: "+t.name);return new Q(!0,t)}}var Z;self.onmessage=function(t){var e=t.data,r=e.options,s=e.trainingSet,o=e.labels;(Z=new Q(r)).train(s,o);var n=JSON.parse(JSON.stringify(Z));postMessage(n)}}]);